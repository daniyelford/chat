<template>
  <div class="otp-container">
    {{ otpError??'' }}
    {{ otpvalue }}
    <input
      v-for="(digit, i) in digits"
      :key="i"
      type="text"
      class="digit-box"
      :class="{ bounce: digit !== '' }"
      v-model="digits[i]"
      maxlength="1"
      @keyup="handleKeyDown($event, i)"
      />
  </div>
</template>
<script setup>
  import { nextTick, defineProps, defineEmits, watch, ref, onMounted } from "vue";
  const otpError= ref('')
  const otpvalue= ref(null)
  const props = defineProps({
    modelValue: { type: String, default: "" },
    length: { type: Number, default: 6 },
  });
  const emit = defineEmits(["update:modelValue"]);
  const digits = ref(Array.from({ length: props.length }, (_, i) => props.modelValue[i] || ""));
  const handleKeyDown = (e, i) => {
    const inputs = e.currentTarget.parentElement.children;
    const isDigit = /^[0-9]$/.test(e.key);
    if (!isDigit && !["Backspace","ArrowLeft","ArrowRight","Tab"].includes(e.key)) {
      e.preventDefault();
      return;
    }
    if (isDigit) {
      digits.value[i] = e.key;
      e.preventDefault();
      if (i < digits.value.length - 1) {
        nextTick(() => inputs[i + 1].focus());
      }
      return;
    }
    if (e.key === "Backspace") {
      digits.value[i] = "";
      e.preventDefault();
      if (i > 0) {
        nextTick(() => inputs[i - 1].focus());
      }
      return;
    }
    if (e.key === "ArrowLeft" && i > 0) {
      nextTick(() => inputs[i - 1].focus());
    }
    if (e.key === "ArrowRight" && i < digits.value.length - 1) {
      nextTick(() => inputs[i + 1].focus());
    }
  };
  watch(digits, () => {
    emit("update:modelValue", digits.value.join(""));
  }, { deep: true });
  onMounted(() => {
    const style = document.createElement('style');
    style.textContent = `
    .otp-container { direction: ltr;display: flex; gap: 0.5rem; justify-content: space-evenly; }
    .digit-box { width: 1.5rem; height: 2rem; font-size: 1rem; text-align: center; border: 2px solid black; border-radius: 6px; }
    .bounce { animation: pulse 0.3s ease-in-out alternate; } 
      @keyframes pulse { 0% { transform: scale(1); } 100% { transform: scale(1.1); } }
    `;
    document.head.appendChild(style);
    if ("OTPCredential" in window) {
      const ac = new AbortController();
      navigator.credentials
        .get({
          otp: { transport: ["sms"] },
          signal: ac.signal,
        })
        .then((otp) => {
          otpvalue.value = otp;
          if (otp?.code) {
            digits.value = otp.code.split("").slice(0, props.length);
          } else {
            otpError.value = "OTP code not received!";
          }
        })
        .catch((err) => {
          // console.warn("OTP AutoFill failed:", err.message);
          otpError.value = err.message;
        });
    } else {
      console.log("WebOTP not supported on this device.");
    }
  });
</script>