import { ref as c, watch as V, onMounted as T, nextTick as r, createElementBlock as d, openBlock as p, Fragment as v, createTextVNode as A, createElementVNode as C, toDisplayString as m, renderList as D, withDirectives as I, normalizeClass as j, vModelText as B } from "vue";
const K = { class: "otp-container" }, M = ["onUpdate:modelValue", "onInput", "onKeydown"], O = {
  __name: "OtpInput",
  props: {
    modelValue: { type: String, default: "" },
    length: { type: Number, default: 6 }
  },
  emits: ["update:modelValue"],
  setup(y, { emit: x }) {
    const u = c(""), i = c(""), g = c(""), s = y, w = x, o = c(Array.from({ length: s.length }, (n, e) => s.modelValue[e] || "")), _ = (n) => {
      const e = { "۰": "0", "۱": "1", "۲": "2", "۳": "3", "۴": "4", "۵": "5", "۶": "6", "۷": "7", "۸": "8", "۹": "9" };
      return n.replace(/[۰-۹]/g, (t) => e[t]);
    }, k = (n, e) => {
      const t = _(n.target.value).replace(/[^0-9]/g, "").charAt(0) || "";
      o.value[e] = t, t && e < o.value.length - 1 && r(() => n.target.parentElement.children[e + 1].focus());
    }, b = (n, e) => {
      const t = n.currentTarget.parentElement.children;
      if (n.key === "Backspace") {
        !o.value[e] && e > 0 && r(() => t[e - 1].focus());
        return;
      }
      n.key === "ArrowLeft" && e > 0 && r(() => t[e - 1].focus()), n.key === "ArrowRight" && e < o.value.length - 1 && r(() => t[e + 1].focus());
    };
    return V(o, () => {
      w("update:modelValue", o.value.join("")), i.value = o.value.join("");
    }, { deep: !0 }), T(() => {
      const n = document.createElement("style");
      if (n.textContent = `
    .otp-container { direction: ltr;display: flex; gap: 0.5rem; justify-content: space-evenly; }
    .digit-box { width: 1.5rem; height: 2rem; font-size: 1rem; text-align: center; border: 2px solid black; border-radius: 6px; }
    .bounce { animation: pulse 0.3s ease-in-out alternate; } 
      @keyframes pulse { 0% { transform: scale(1); } 100% { transform: scale(1.1); } }
    `, document.head.appendChild(n), "OTPCredential" in window) {
        const e = new AbortController();
        navigator.credentials.get({
          otp: { transport: ["sms"] },
          signal: e.signal
        }).then((t) => {
          if (t?.code) {
            i.value = t.code, g.value = t.type;
            const l = t.code.split("").slice(0, s.length);
            o.value = l, r(() => {
              const a = document.querySelectorAll(".otp-container input");
              l.forEach((E, f) => {
                a[f] && (a[f].value = E);
              });
              const h = Math.min(l.length, s.length) - 1;
              a[h] && a[h].focus();
            });
          } else
            u.value = "OTP code not received!";
        }).catch((t) => {
          u.value = t.message;
        });
      }
    }), (n, e) => (p(), d(v, null, [
      A(m(u.value ?? "") + " " + m(i.value ?? "") + " " + m(g.value ?? "") + " ", 1),
      C("div", K, [
        (p(!0), d(v, null, D(o.value, (t, l) => I((p(), d("input", {
          key: l,
          type: "text",
          class: j(["digit-box", { bounce: t !== "" }]),
          "onUpdate:modelValue": (a) => o.value[l] = a,
          maxlength: "1",
          onInput: (a) => k(a, l),
          onKeydown: (a) => b(a, l)
        }, null, 42, M)), [
          [B, o.value[l]]
        ])), 128))
      ])
    ], 64));
  }
};
export {
  O as default
};
